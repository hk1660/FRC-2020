/*
 *  Software License Agreement
 *
 * Copyright (C) Cross The Road Electronics.  All rights
 * reserved.
 *
 * Cross The Road Electronics (CTRE) licenses to you the right to
 * use, publish, and distribute copies of CRF (Cross The Road) firmware files (*.crf) and Software
 * API Libraries ONLY when in use with Cross The Road Electronics hardware products.
 *
 * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT
 * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * CROSS THE ROAD ELECTRONICS BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF
 * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
 * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE
 * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER
 * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT
 * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE
 */
package com.ctre.phoenix.sensors;
import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.ErrorCollection;
import com.ctre.phoenix.ParamEnum;
import com.ctre.phoenix.sensors.CANCoderConfigUtil;

public class CANCoder{
    private long m_handle;

    private int m_deviceNumber;

    /**
     * Constructor.
     * @param deviceNumber	The CAN Device ID of the CANCoder.
     */
    public CANCoder(int deviceNumber){
        m_handle = CANCoderJNI.Create(deviceNumber);
        m_deviceNumber = deviceNumber;
    }

    public ErrorCode DestroyObject() {
        return ErrorCode.valueOf(CANCoderJNI.Destroy(m_handle));
    }

    public int getDeviceID() {
        return m_deviceNumber;
    }

    /**
     * Gets the position of the sensor.  This may be relative or absolute depending on configuration.
     * The units are determined by the coefficient and unit-string configuration params, default is degrees.
     * @return The position of the sensor.
     */
    public double getPosition() {
        return CANCoderJNI.GetPosition(m_handle);
    }
    /**
     * Sets the position of the sensor.
     * The units are determined by the coefficient and unit-string configuration params, default is degrees.
     * @param newPosition
     * @return ErrorCode generated by function. 0 indicates no error.
     */
    public ErrorCode setPosition(double newPosition, int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.SetPosition(m_handle, newPosition, timeoutMs));
    }
    /**
     * Sets the position of the sensor.
     * The units are determined by the coefficient and unit-string configuration params, default is degrees.
     * @param newPosition
     * @return ErrorCode generated by function. 0 indicates no error.
     */
    public ErrorCode setPosition(double newPosition) {
        int timeoutMs = 0;
        return ErrorCode.valueOf(CANCoderJNI.SetPosition(m_handle, newPosition, timeoutMs));
    }
    /**
     * Sets the position of the sensor to match the magnet's "Absolute Sensor".
     * The units are determined by the coefficient and unit-string configuration params, default is degrees.
     * @return ErrorCode generated by function. 0 indicates no error.
     */
    public ErrorCode setPositionToAbsolute(int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.SetPositionToAbsolute(m_handle, timeoutMs));
    }
    /**
     * Sets the position of the sensor to match the magnet's "Absolute Sensor".
     * The units are determined by the coefficient and unit-string configuration params, default is degrees.
     * @return ErrorCode generated by function. 0 indicates no error.
     */
    public ErrorCode setPositionToAbsolute() {
        int timeoutMs = 0;
        return ErrorCode.valueOf(CANCoderJNI.SetPositionToAbsolute(m_handle, timeoutMs));
    }
    /**
     * Gets the velocity of the sensor.
     * The units are determined by the coefficient and unit-string configuration params, default is degrees per second.
     * @return The Velocity of the sensor.
     */
    public double getVelocity() {
        return CANCoderJNI.GetVelocity(m_handle);
    }
    /**
     * Gets the absolute position of the sensor.
     * The absolute position may be unsigned (for example: [0,360) deg), or signed (for example: [-180,+180) deg).  This is determined by a configuration.  The default selection is unsigned.
     * The units are determined by the coefficient and unit-string configuration params, default is degrees.
     * Note: this signal is not affected by calls to SetPosition().
     * @return The position of the sensor.
     */
    public double getAbsolutePosition() {
        return CANCoderJNI.GetAbsolutePosition(m_handle);
    }
    /**
     * Configures the period of each velocity sample.
     * Every 1ms a position value is sampled, and the delta between that sample
     * and the position sampled kPeriod ms ago is inserted into a filter.
     * kPeriod is configured with this function.
     *
     * @param period
     *            Desired period for the velocity measurement.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementPeriod(SensorVelocityMeasPeriod period, int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.ConfigVelocityMeasurementPeriod(m_handle, period.value, timeoutMs));
    }
    /**
     * Configures the period of each velocity sample.
     * Every 1ms a position value is sampled, and the delta between that sample
     * and the position sampled kPeriod ms ago is inserted into a filter.
     * kPeriod is configured with this function.
     *
     * @param period
     *            Desired period for the velocity measurement.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementPeriod(SensorVelocityMeasPeriod period) {
        int timeoutMs = 0;
        return configVelocityMeasurementPeriod(period, timeoutMs);
    }
    /**
     * Sets the number of velocity samples used in the rolling average velocity
     * measurement.
     *
     * @param windowSize
     *            Number of samples in the rolling average of velocity
     *            measurement. Valid values are 1,2,4,8,16,32. If another
     *            value is specified, it will truncate to nearest support value.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementWindow(int windowSize, int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.ConfigVelocityMeasurementWindow(m_handle, windowSize, timeoutMs));
    }
    /**
     * Sets the number of velocity samples used in the rolling average velocity
     * measurement.
     *
     * @param windowSize
     *            Number of samples in the rolling average of velocity
     *            measurement. Valid values are 1,2,4,8,16,32. If another
     *            value is specified, it will truncate to nearest support value.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configVelocityMeasurementWindow(int windowSize) {
        int timeoutMs = 0;
        return configVelocityMeasurementWindow(windowSize, timeoutMs);
    }
    /**
     * Sets the signage and range of the "Absolute Position" signal.
     * Choose unsigned for an absolute range of [0,+1) rotations, [0,360) deg, etc...
     * Choose signed for an absolute range of [-0.5,+0.5) rotations, [-180,+180) deg, etc...
     * @param absoluteSensorRange
     *            Desired Sign/Range for the absolute position register.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configAbsoluteSensorRange(AbsoluteSensorRange absoluteSensorRange, int timeoutMs)
    {
        return ErrorCode.valueOf(CANCoderJNI.ConfigAbsoluteSensorRange(m_handle, absoluteSensorRange.value, timeoutMs));
    }
    /**
     * Sets the signage and range of the "Absolute Position" signal.
     * Choose unsigned for an absolute range of [0,+1) rotations, [0,360) deg, etc...
     * Choose signed for an absolute range of [-0.5,+0.5) rotations, [-180,+180) deg, etc...
     * @param absoluteSensorRange
     *            Desired Sign/Range for the absolute position register.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configAbsoluteSensorRange(AbsoluteSensorRange absoluteSensorRange)
    {
        int timeoutMs = 0;
        return configAbsoluteSensorRange(absoluteSensorRange, timeoutMs);
    }
    /**
     * Adjusts the zero point for the absolute position register.
     * The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
     * and a hard-limited mechanism may have such a discontinuity in its functional range.
     * In which case use this config to move the discontinuity outside of the function range.
     * @param offsetDegrees
     *            Offset in degrees (unit string and coefficient DO NOT apply for this config).
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMagnetOffset(double offsetDegrees, int timeoutMs)
    {
        return ErrorCode.valueOf(CANCoderJNI.ConfigMagnetOffset(m_handle, offsetDegrees, timeoutMs));
    }
    /**
     * Adjusts the zero point for the absolute position register.
     * The absolute position of the sensor will always have a discontinuity (360 -> 0 deg) or (+180 -> -180)
     * and a hard-limited mechanism may have such a discontinuity in its functional range.
     * In which case use this config to move the discontinuity outside of the function range.
     * @param offsetDegrees
     *            Offset in degrees (unit string and coefficient DO NOT apply for this config).
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configMagnetOffset(double offsetDegrees)
    {
        int timeoutMs = 0;
        return configMagnetOffset(offsetDegrees, timeoutMs);
    }
    /**
     * Pick the strategy on how to initialize the CANCoder's "Position" register.  Depending on the mechanism,
     * it may be desirable to auto set the Position register to match the Absolute Position (swerve for example).
     * Or it may be desired to zero the sensor on boot (drivetrain translation sensor or a relative servo).
     *
     * TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the CANCoder is reset.
     *
     * @param initializationStrategy
     *            The sensor initialization strategy to use.  This will impact the behavior the next time CANCoder boots up.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorInitializationStrategy(SensorInitializationStrategy initializationStrategy, int timeoutMs)
    {
        return ErrorCode.valueOf(CANCoderJNI.ConfigSensorInitializationStrategy(m_handle, initializationStrategy.value, timeoutMs));
    }
    /**
     * Pick the strategy on how to initialize the CANCoder's "Position" register.  Depending on the mechanism,
     * it may be desirable to auto set the Position register to match the Absolute Position (swerve for example).
     * Or it may be desired to zero the sensor on boot (drivetrain translation sensor or a relative servo).
     *
     * TIP: Tuner's self-test feature will report what the boot sensor value will be in the event the CANCoder is reset.
     *
     * @param initializationStrategy
     *            The sensor initialization strategy to use.  This will impact the behavior the next time CANCoder boots up.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorInitializationStrategy(SensorInitializationStrategy initializationStrategy)
    {
        int timeoutMs = 0;
        return configSensorInitializationStrategy(initializationStrategy, timeoutMs);
    }
    /**
     * Choose what units you want the API to get/set.  This also impacts the units displayed in Self-Test in Tuner.
     * Depending on your mechanism, you may want to scale rotational units (deg, radians, rotations), or scale to a distance (inches, centimeters).
     * @param sensorCoefficient
     *            Scalar to multiply the CANCoder's native 12-bit resolute sensor. Defaults to 0.087890625 to produce degrees.
     * @param unitString
     *            String holding the unit to report in.  This impacts all routines (except for ConfigMagnetOffset) and the self-test in Tuner.
     *            The string value itself is arbitrary.  The max number of letters will depend on firmware versioning, but generally CANCoder
     *            supports up to eight letters.  However, common units such as "centimeters" are supported explicitly despite exceeding the eight-letter limit.
     *			  Default is "deg"
     * @param sensorTimeBase
     *            Desired denominator to report velocity in.  This impacts GetVelocity and the reported velocity in self-test in Tuner.
     *            Default is "Per Second".
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFeedbackCoefficient(double sensorCoefficient, String unitString, SensorTimeBase sensorTimeBase, int timeoutMs)
    {
        return ErrorCode.valueOf(CANCoderJNI.ConfigFeedbackCoefficient(m_handle, sensorCoefficient, unitString, sensorTimeBase.value, timeoutMs));
    }
    /**
     * Choose what units you want the API to get/set.  This also impacts the units displayed in Self-Test in Tuner.
     * Depending on your mechanism, you may want to scale rotational units (deg, radians, rotations), or scale to a distance (inches, centimeters).
     * @param sensorCoefficient
     *            Scalar to multiply the CANCoder's native 12-bit resolute sensor. Defaults to 0.087890625 to produce degrees.
     * @param unitString
     *            String holding the unit to report in.  This impacts all routines (except for ConfigMagnetOffset) and the self-test in Tuner.
     *            The string value itself is arbitrary.  The max number of letters will depend on firmware versioning, but generally CANCoder
     *            supports up to eight letters.  However, common units such as "centimeters" are supported explicitly despite exceeding the eight-letter limit.
     *			  Default is "deg"
     * @param sensorTimeBase
     *            Desired denominator to report velocity in.  This impacts GetVelocity and the reported velocity in self-test in Tuner.
     *            Default is "Per Second".
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFeedbackCoefficient(double sensorCoefficient, String unitString, SensorTimeBase sensorTimeBase)
    {
        int timeoutMs = 0;
        return configFeedbackCoefficient(sensorCoefficient, unitString, sensorTimeBase, timeoutMs);
    }
    /**
     * Gets the bus voltage seen by the device.
     *
     * @return The bus voltage value (in volts).
     */
    public double getBusVoltage() {
        return CANCoderJNI.GetBusVoltage(m_handle);
    }
    /**
     * Gets the magnet's health.
     *
     * @return The magnet health code (red/orange/green).
     */
    public MagnetFieldStrength getMagnetFieldStrength() {
        return MagnetFieldStrength.valueOf(CANCoderJNI.GetMagnetFieldStrength(m_handle));
    }
    /**
     * Choose which direction is interpreted as positive displacement.
     * This affects both "Position" and "Absolute Position".
     * @param bSensorDirection
     *            False (default) means positive rotation occurs when magnet
     *            is spun counter-clockwise when observer is facing the LED side of CANCoder.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorDirection(boolean bSensorDirection, int timeoutMs)
    {
        return ErrorCode.valueOf(CANCoderJNI.ConfigSensorDirection(m_handle, bSensorDirection ? 1:0, timeoutMs));
    }
    /**
     * Choose which direction is interpreted as positive displacement.
     * This affects both "Position" and "Absolute Position".
     * @param bSensorDirection
     *            False (default) means positive rotation occurs when magnet
     *            is spun counter-clockwise when observer is facing the LED side of CANCoder.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSensorDirection(boolean bSensorDirection)
    {
        int timeoutMs = 0;
        return configSensorDirection(bSensorDirection, timeoutMs);
    }
    /**
     * Call GetLastError() generated by this object.
     * Not all functions return an error code but can
     * potentially report errors.
     *
     * This function can be used to retrieve those error codes.
     *
     * @return The last ErrorCode generated.
     */
    public ErrorCode getLastError() {
        return ErrorCode.valueOf(CANCoderJNI.GetLastError(m_handle));
    }

    /**
     * Get the units for the signal retrieved in the last called get routine.
     */
    public String getLastUnitString() {
        return CANCoderJNI.GetLastUnitString(m_handle);
    }

    /**
     * Get the timestamp of the CAN frame retrieved in the last called get routine.
     */
    public double getLastTimestamp() {
        return CANCoderJNI.GetLastTimestamp(m_handle);
    }

    //------ Custom Persistent Params ----------//

    /**
     * Sets the value of a custom parameter. This is for arbitrary use.
     *
     * Sometimes it is necessary to save calibration/duty cycle/output
     * information in the device. Particularly if the
     * device is part of a subsystem that can be replaced.
     *
     * @param newValue
     *            Value for custom parameter.
     * @param paramIndex
     *            Index of custom parameter. [0-1]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetCustomParam(int newValue,
        int paramIndex, int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.ConfigSetCustomParam(m_handle, newValue, paramIndex, timeoutMs));
    }
    /**
     * Sets the value of a custom parameter. This is for arbitrary use.
     *
     * Sometimes it is necessary to save calibration/duty cycle/output
     * information in the device. Particularly if the
     * device is part of a subsystem that can be replaced.
     *
     * @param newValue
     *            Value for custom parameter.
     * @param paramIndex
     *            Index of custom parameter. [0-1]
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetCustomParam(int newValue,
        int paramIndex) {
        int timeoutMs = 0;
        return configSetCustomParam(newValue, paramIndex, timeoutMs);
    }
    /**
     * Gets the value of a custom parameter. This is for arbitrary use.
     *
     * Sometimes it is necessary to save calibration/duty cycle/output
     * information in the device. Particularly if the
     * device is part of a subsystem that can be replaced.
     *
     * @param paramIndex
     *            Index of custom parameter. [0-1]
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Value of the custom param.
     */
    public int configGetCustomParam(int paramIndex, int timeoutMs) {
        return CANCoderJNI.ConfigGetCustomParam(m_handle, paramIndex, timeoutMs);
    }
    /**
     * Gets the value of a custom parameter. This is for arbitrary use.
     *
     * Sometimes it is necessary to save calibration/duty cycle/output
     * information in the device. Particularly if the
     * device is part of a subsystem that can be replaced.
     *
     * @param paramIndex
     *            Index of custom parameter. [0-1]
     * @return Value of the custom param.
     */
    public int configGetCustomParam(int paramIndex) {
        int timeoutMs = 0;
        return configGetCustomParam(paramIndex, timeoutMs);
    }

    //------ Generic Param API, typically not used ----------//
    /**
     * Sets a parameter. Generally this is not used.
     * This can be utilized in
     * - Using new features without updating API installation.
     * - Errata workarounds to circumvent API implementation.
     * - Allows for rapid testing / unit testing of firmware.
     *
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetParameter(ParamEnum param, double value,
        int subValue, int ordinal, int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.ConfigSetParameter(m_handle, param.value, value, subValue, ordinal, timeoutMs));

    }
    /**
     * Sets a parameter. Generally this is not used.
     * This can be utilized in
     * - Using new features without updating API installation.
     * - Errata workarounds to circumvent API implementation.
     * - Allows for rapid testing / unit testing of firmware.
     *
     * @param param
     *            Parameter enumeration.
     * @param value
     *            Value of parameter.
     * @param subValue
     *            Subvalue for parameter. Maximum value of 255.
     * @param ordinal
     *            Ordinal of parameter.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configSetParameter(ParamEnum param, double value,
        int subValue, int ordinal) {
        int timeoutMs = 0;
        return configSetParameter(param, value, subValue, ordinal, timeoutMs);

    }
    /**
     * Gets a parameter. Generally this is not used.
     * This can be utilized in
     * - Using new features without updating API installation.
     * - Errata workarounds to circumvent API implementation.
     * - Allows for rapid testing / unit testing of firmware.
     *
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Value of parameter.
     */
    public double configGetParameter(ParamEnum param, int ordinal, int timeoutMs) {
        return CANCoderJNI.ConfigGetParameter(m_handle, param.value, ordinal, timeoutMs);
    }
    /**
     * Gets a parameter. Generally this is not used.
     * This can be utilized in
     * - Using new features without updating API installation.
     * - Errata workarounds to circumvent API implementation.
     * - Allows for rapid testing / unit testing of firmware.
     *
     * @param param
     *            Parameter enumeration.
     * @param ordinal
     *            Ordinal of parameter.
     * @return Value of parameter.
     */
    public double configGetParameter(ParamEnum param, int ordinal) {
        int timeoutMs = 0;
        return configGetParameter(param, ordinal, timeoutMs);
    }

    //------ Frames ----------//
    /**
     * Sets the period of the given status frame.
     *
     * @param statusFrame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setStatusFramePeriod(CANCoderStatusFrame statusFrame, int periodMs, int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.SetStatusFramePeriod(m_handle, statusFrame.value, periodMs, timeoutMs));
    }
    /**
     * Sets the period of the given status frame.
     *
     * @param statusFrame
     *            Frame whose period is to be changed.
     * @param periodMs
     *            Period in ms for the given frame.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode setStatusFramePeriod(CANCoderStatusFrame statusFrame, int periodMs) {
        int timeoutMs = 0;
        return setStatusFramePeriod(statusFrame, periodMs, timeoutMs);
    }
    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @param timeoutMs
     *            Timeout value in ms. If nonzero, function will wait for
     *            config success and report an error if it times out.
     *            If zero, no blocking or checking is performed.
     * @return Period of the given status frame.
     */
    public int getStatusFramePeriod(CANCoderStatusFrame frame,
        int timeoutMs) {
        return CANCoderJNI.GetStatusFramePeriod(m_handle, frame.value, timeoutMs);
    }
    /**
     * Gets the period of the given status frame.
     *
     * @param frame
     *            Frame to get the period of.
     * @return Period of the given status frame.
     */
    public int getStatusFramePeriod(CANCoderStatusFrame frame) {
        int timeoutMs = 0;
        return getStatusFramePeriod(frame, timeoutMs);
    }
    //------ Firmware ----------//
    /**
     * Gets the firmware version of the device.
     *
     * @return Firmware version of device.
     */
    public int getFirmwareVersion() {
        return CANCoderJNI.GetFirmwareVersion(m_handle);
    }
    /**
     * Returns true if the device has reset since last call.
     *
     * @return Has a Device Reset Occurred?
     */
    public boolean hasResetOccurred() {
        return CANCoderJNI.HasResetOccurred(m_handle);
    }
    //------ Faults ----------//
    /**
     * Gets the CANCoder fault status
     *
     * @param toFill
     *            Container for fault statuses.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode getFaults(CANCoderFaults toFill) {
        int bits = CANCoderJNI.GetFaults(m_handle);
        toFill.update(bits);
        return getLastError();
    }
    /**
     * Gets the CANCoder sticky fault status
     *
     * @param toFill
     *            Container for sticky fault statuses.
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode getStickyFaults(CANCoderStickyFaults toFill) {
        int bits = CANCoderJNI.GetStickyFaults(m_handle);
        toFill.update(bits);
        return getLastError();
    }
    /**
     * Clears the Sticky Faults
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode clearStickyFaults(int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.ClearStickyFaults(m_handle, timeoutMs));
    }
    /**
     * Clears the Sticky Faults
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode clearStickyFaults() {
        int timeoutMs = 0;
        return clearStickyFaults(timeoutMs);
    }

    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public SensorVelocityMeasPeriod configGetVelocityMeasurementPeriod(int timeoutMs)
    {
        return SensorVelocityMeasPeriod.valueOf(CANCoderJNI.ConfigGetVelocityMeasurementPeriod(m_handle, timeoutMs));
    }
    /**
     * @return Read value of the config param.
     */
    public SensorVelocityMeasPeriod configGetVelocityMeasurementPeriod()
    {
        int timeoutMs = 50;
        return configGetVelocityMeasurementPeriod(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public int configGetVelocityMeasurementWindow(int timeoutMs)
    {
        return CANCoderJNI.ConfigGetVelocityMeasurementWindow(m_handle, timeoutMs);
    }
    /**
     * @return Read value of the config param.
     */
    public int configGetVelocityMeasurementWindow()
    {
        int timeoutMs = 50;
        return configGetVelocityMeasurementWindow(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public AbsoluteSensorRange configGetAbsoluteSensorRange(int timeoutMs)
    {
        return AbsoluteSensorRange.valueOf(CANCoderJNI.ConfigGetAbsoluteSensorRange(m_handle, timeoutMs));
    }
    /**
     * @return Read value of the config param.
     */
    public AbsoluteSensorRange configGetAbsoluteSensorRange()
    {
        int timeoutMs = 50;
        return configGetAbsoluteSensorRange(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public double configGetMagnetOffset(int timeoutMs)
    {
        return CANCoderJNI.ConfigGetMagnetOffset(m_handle, timeoutMs);
    }
    /**
     * @return Read value of the config param.
     */
    public double configGetMagnetOffset()
    {
        int timeoutMs = 50;
        return configGetMagnetOffset(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public boolean configGetSensorDirection(int timeoutMs)
    {
        return 0 != CANCoderJNI.ConfigGetSensorDirection(m_handle, timeoutMs);
    }
    /**
     * @return Read value of the config param.
     */
    public boolean configGetSensorDirection()
    {
        int timeoutMs = 50;
        return configGetSensorDirection(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public SensorInitializationStrategy configGetSensorInitializationStrategy(int timeoutMs)
    {
        return SensorInitializationStrategy.valueOf(CANCoderJNI.ConfigGetSensorInitializationStrategy(m_handle, timeoutMs));
    }
    /**
     * @return Read value of the config param.
     */
    public SensorInitializationStrategy configGetSensorInitializationStrategy()
    {
        int timeoutMs = 50;
        return configGetSensorInitializationStrategy(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public double configGetFeedbackCoefficient(int timeoutMs)
    {
        return CANCoderJNI.ConfigGetFeedbackCoefficient(m_handle, timeoutMs);
    }
    /**
     * @return Read value of the config param.
     */
    public double configGetFeedbackCoefficient()
    {
        int timeoutMs = 50;
        return configGetFeedbackCoefficient(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public String configGetFeedbackUnitString(int timeoutMs)
    {
        return CANCoderJNI.ConfigGetFeedbackUnitString(m_handle, timeoutMs);
    }
    /**
     * @return Read value of the config param.
     */
    public String configGetFeedbackUnitString()
    {
        int timeoutMs = 50;
        return configGetFeedbackUnitString(timeoutMs);
    }
    /**
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     * @return Read value of the config param.
     */
    public SensorTimeBase configGetFeedbackTimeBase(int timeoutMs)
    {
        return SensorTimeBase.valueOf(CANCoderJNI.ConfigGetFeedbackTimeBase(m_handle, timeoutMs));
    }
    /**
     * @return Read value of the config param.
     */
    public SensorTimeBase configGetFeedbackTimeBase()
    {
        int timeoutMs = 50;
        return configGetFeedbackTimeBase(timeoutMs);
    }

    /**
     * Configures all persistent settings.
     *
     * @param allConfigs        Object with all of the persistant settings
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configAllSettings(CANCoderConfiguration allConfigs, int timeoutMs) {

        ErrorCollection errorCollection = new ErrorCollection();
        errorCollection.NewError(configFactoryDefault(timeoutMs));

        if (CANCoderConfigUtil.velocityMeasurementPeriodDifferent(allConfigs)) errorCollection.NewError(configVelocityMeasurementPeriod(allConfigs.velocityMeasurementPeriod, timeoutMs));
        if (CANCoderConfigUtil.velocityMeasurementWindowDifferent(allConfigs)) errorCollection.NewError(configVelocityMeasurementWindow(allConfigs.velocityMeasurementWindow, timeoutMs));
        if (CANCoderConfigUtil.customParam0Different(allConfigs)) errorCollection.NewError(configSetCustomParam(allConfigs.customParam0, 0, timeoutMs));
        if (CANCoderConfigUtil.customParam1Different(allConfigs)) errorCollection.NewError(configSetCustomParam(allConfigs.customParam1, 1, timeoutMs));
		if (CANCoderConfigUtil.absoluteSensorRangeDifferent(allConfigs)) errorCollection.NewError(configAbsoluteSensorRange(allConfigs.absoluteSensorRange, timeoutMs));
		if (CANCoderConfigUtil.magnetOffsetDegreesDifferent(allConfigs)) errorCollection.NewError(configMagnetOffset(allConfigs.magnetOffsetDegrees, timeoutMs));
		if (CANCoderConfigUtil.sensorDirectionDifferent(allConfigs)) errorCollection.NewError(configSensorDirection(allConfigs.sensorDirection, timeoutMs));
		if (CANCoderConfigUtil.initializationStrategyDifferent(allConfigs)) errorCollection.NewError(configSensorInitializationStrategy(allConfigs.initializationStrategy, timeoutMs));
		if (CANCoderConfigUtil.sensorCoefficientDifferent(allConfigs) ||
                CANCoderConfigUtil.unitStringDifferent(allConfigs) ||
                CANCoderConfigUtil.sensorTimeBaseDifferent(allConfigs)) {
            errorCollection.NewError(configFeedbackCoefficient(allConfigs.sensorCoefficient, allConfigs.unitString, allConfigs.sensorTimeBase, timeoutMs));
        }

        return errorCollection._worstError;
    }
    /**
     * Configures all persistent settings (overloaded so timeoutMs is 50 ms).
     *
	 * @param allConfigs        Object with all of the persistant settings
     *
     * @return Error Code generated by function. 0 indicates no error. 
     */
	public ErrorCode configAllSettings(CANCoderConfiguration allConfigs) {
		int timeoutMs = 50;
		return configAllSettings(allConfigs, timeoutMs);
	}

    /**
     * Gets all persistant settings.
     *
     * @param allConfigs        Object with all of the persistant settings
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     */
    public void getAllConfigs(CANCoderConfiguration allConfigs, int timeoutMs) {
        allConfigs.velocityMeasurementPeriod = configGetVelocityMeasurementPeriod(timeoutMs);
        allConfigs.velocityMeasurementWindow = configGetVelocityMeasurementWindow(timeoutMs);
        allConfigs.customParam0 = (int)configGetParameter(ParamEnum.eCustomParam, 0, timeoutMs);
        allConfigs.customParam1 = (int)configGetParameter(ParamEnum.eCustomParam, 1, timeoutMs);
        allConfigs.absoluteSensorRange = configGetAbsoluteSensorRange(timeoutMs);
        allConfigs.magnetOffsetDegrees = configGetMagnetOffset(timeoutMs);
        allConfigs.sensorDirection = configGetSensorDirection(timeoutMs);
        allConfigs.initializationStrategy = configGetSensorInitializationStrategy(timeoutMs);
        allConfigs.sensorCoefficient = configGetFeedbackCoefficient(timeoutMs);
        allConfigs.unitString = configGetFeedbackUnitString(timeoutMs);
        allConfigs.sensorTimeBase = configGetFeedbackTimeBase(timeoutMs);
    }
    /**
     * Gets all persistant settings (overloaded so timeoutMs is 50 ms).
     *
	 * @param allConfigs        Object with all of the persistant settings
     */
    public void getAllConfigs(CANCoderConfiguration allConfigs) {
        int timeoutMs = 50;
        getAllConfigs(allConfigs, timeoutMs);
    }

    /**
     * Configures all persistent settings to defaults.
     *
     * @param timeoutMs
     *              Timeout value in ms. If nonzero, function will wait for
     *              config success and report an error if it times out.
     *              If zero, no blocking or checking is performed.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFactoryDefault(int timeoutMs) {
        return ErrorCode.valueOf(CANCoderJNI.ConfigFactoryDefault(m_handle, timeoutMs));
    }
    /**
     * Configures all persistent settings to defaults.
     *
     * @return Error Code generated by function. 0 indicates no error.
     */
    public ErrorCode configFactoryDefault() {
        int timeoutMs = 50;
        return configFactoryDefault(timeoutMs);
    }
}